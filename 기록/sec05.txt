5. 캡슐의 은닉성과 접근 지정자
캡슐에서 오류가나면 그 캡슐에서 오류가남.
함수가 다른 캡슐의 데이터를 사용하려고 넘겨받으면? 캡슐을 깨뜨리는 것이다.
사용하려면 함수룰 호출하는 방향으로 가야한다. 
자바는 보호막을 씌워서 쓰고싶어도 못쓰게 만들 수있다.
캡슐을 깨지 못하게 하는 접근제어지시자가 그 역할을 한다.
키워드를 통해 공개할지 말지를 정할 수 있다.
사진참조

공개하고 싶지않는 것은 공개하지 않는게 캡슐화에서 중요한 점이다.
데이터 구조에 대해서는 거의 필수로 거는게 낫다.

private Exam[] exams;
private int current;

함수는 공개하고자하는 것, 서비스해야할 것은 public
캡슐이란 자기가 숨겨야할 것에 대해서 은닉시킬 수 있어야하고 그걸 위한 도구가 접근제어지시자가 있다.

6. 생성자(Constructor)
객체 초기화
new ExamList();하면 객체가 생성하면 실체화하는 작업이 이루어지고 데이터구조가 메모리에 올라가게 된다.
이걸 사용하기 위해 이름을 부여하는데 이것이	ExamList list = new ExamList(); 이다.
처음에 만들기 위해서값을 초기화하기 위해서 init을 실행시켯다.
이상태를 가지고 업무적인 동작을 하면 하나씩 계산되게 된다.
그런데 누군가가 중간에 init를 또 호출하면? current가 0이되버린다.
어찌보면 객체 초기화용이아닌 리셋용이 되버린다.
우리가 필요로하는 초기화는 
1.객체가 생성되자마자 무조건 제일 먼저 실행되어야한다.
2.생성될때 단 한번만 실행되어야만 한다.
이 함수가 바로 '생성자'이다. 그런데 생성자는 이름을 가지지않아 함수라기엔 애매해서 생성자라고 부르자.
그럼 생성자는 어떻게 생성하나? 객체 생성마다 생성자를 호출하고 있다.
new ExamList();는 new ExamList + ();이게 합쳐져있는 거엿다. 객체를 불러주고 그걸 초기화하는 생성자를 불러달라 이것이다.

생성자는 이름도 반환타입도 없다.
public 클래스이름(){}
정의할때의 함수명은 초기화 할 객체를 한정하기 위한 형식 명칭이다.

public ExamList() {
	exams = new Exam[3];
	current = 0;
}


7.  생성자 오버로드(Constructor Overload)
생성자도 함수의 특징을 가지고 잇어서 오버로드를 할 수있다.

public ExamList(int size) {
	exams = new Exam[size];
	current = 0;
}
->이렇게하면 두가지 방식으로 생성자를 호출 할 수 있다.

주의사항이 있다.
1.오버로드를 만들때 기본생성자를 제거한다면? 기본생성자를 호출할 수 없다.
2.똑같은 기능을 인자를 다르게 하는것이다.오버로드햇다하면 다른것을 줄이고 재호출할 수 있다.
생성자가 생성자를 호출할수 잇냐? 객체를 만들면된다.
public ExamList(){
	this(3)
}
재호출함으로써 중복이 된 부분을 해결할 수있다.
3.생성자를 하나도 정의하지 않는다면 컴파일러가 기본생성자를 만들어줌.
참조변수는 null 기본은 0이니 원하지 않는다면 만들어라
























27. if와 while 문 
제어문 작성순서대로 실행 조건문을 쓰면 이 제어가 어느정도 바꿀수잇다.
조건을 비교할때 비교연산자를 사용

while도 조건을 검사해서 참일때만 실행하는게 비슷함.

if는 한번만 검사하고 실행 while은 조건이 참이면 어떤 조건을 찾을때 까지 계속실행

한구절로 인식하기 위해 {} 안에 넣기
중괄호 내려쓰기 vs 올려쓰기 일관되게 통일을 하는게 좋다.

그런데 if는 한번만 물어보니까 계속 반복해야하면 while로 조건을 물으면 된다
프로그램 제어구조를 직접 적어보고 따라가보자.

System.out.print("국어1:");
kor1 = sc.nextInt();

while (kor1 < 0 || kor1 > 100) {
	// if (!(kor1>=0 && kor1<=100)) {
	// if (kor1 < 0 || kor1>100) {}
	System.out.println("성적 범위(0~100)을 벗어낫습니다.");
	System.out.print("국어1:");
	kor1 = sc.nextInt();
}

28. 제어구조 do while 문
위의 예제는 반복되는 문장이 생겨서 불편하다. 지양해야한다. 흐름을 제어해서 가능하기 때문임.


do {
	System.out.print("국어1:");
	kor1 = sc.nextInt();
	if (kor1 < 0 || kor1 > 100) {
		System.out.println("성적 범위(0~100)을 벗어낫습니다.");
	}
} while(kor1 < 0 || kor1 > 100);
do while문은 흐름이 뒤로감으로써 무조건 한번은 실행하고 확인하고 위로 올라가거나 다음 흐름으로 간다.

29. 제어구조 for문
for문은 특정 수 만큼 반복한다.
국어 1 2 3이 반복된다. 조건처리와는 다르고 갯수만큼 반복해야한다.
첫번째거만 세번반복하게 해보자.

whlie문을 억지로쓰면
int i=0
while(i<3){
	i++;
}
해주면 가능은 하다. 임의적으로 갯수에 맞게하는 패턴을 만들어 본것이다.
그런데 이 세가지 조건이 한눈에 보여야 몇번 반복인지 알 수 있다.
그래서 for문이 생겨나게 되었다.
for(초기화문; 조건식; 증감식) 으로 작성한다.
for(int i = 0 ; i < 3 ; i++){}
일반적으로 패턴은 그대로 두고 출력해서 i+1로 하는게 좋다.
일반적으로 index는 0부터 시작하기 때문임 1부터 시작하려면 i말고 n을쓰자.

만약 거꾸로 3 2 1하고싶다면?
for(int i = 0 ; i < 3 ; i++){
	System.out.printf("\t국어 %d : %3d\n", 3-i, kor1);
}
!!! 몇번 반복하는지 한눈에 파악하기위해 반복문을 건들지말고 출력을 건들자 !!!
for( ; i<3; ){}
for( ; true; ){}
앞뒤 초기화문 증감연산자가 빠진경우 오류가 아님!
조건식에 true? false나올때까지 반복
for( ; ; ){} 조건도 없고 식도 없다면 무한반복
for( int x = 0, int y = 0 ; x<0; x++, y=x ){}
초기화식이 두개 증감식이 두개인 경우? 오류안남 작성가능

무한반복은 while로 사용하자. 용도에 맞게 사용하기.

30. 프로그래머가 수학을 못하면 만들게 되는 코드 #1
프로그래머는 수학을 잘해야한다. why?
1부터 10까지 반복하면서더해본다면?
for (int i = 0 ; i < 10 ; i++) {
	total += 1+i;
}
for문으로 할 수도 있다.
for (int i = 0 ; i < 5 ; i++) {
	total += 3+i;
}
3부터 7까지면? 이렇게 하면됨

그런데 여기서 문제가 발생한다. 프로그래머는 절차를 만드는 사람임. 그래서 문제없다고 생각함.
그런데 이러면 5번 하고 연산이 두번씩 사용됨. 최소 4개이상의 연산이 복사됨.
합을 구하는 공식이 있다.
사진참조
등차수열의 공식을 사용하면 메모리도 시간도 아낄 수잇다.

프로그래머는 절차는 만드는 사람이기때문에 만들엇다고 해도 잘못된게 아니다.
하지만 수학을 조금만이라도 알면 짧은 연산식으로 출력결과를 나타낼수잇다.
고민을 잘해보자

31.제어구조 else if, else
정상적으로 흐름을끊을수있도록 메뉴를 만들어 보자.
System.out.println("┌──────────────────────────┐");
System.out.println("│          메인메뉴        │");
System.out.println("└──────────────────────────┘");

System.out.println("\t1. 성적 입력");
System.out.println("\t2. 성적 출력");
System.out.println("\t3. 종료");
System.out.print("\t선택>");
int menu = sc.nextInt();

변수는 의미를 살릴 수 있는 이름을 붙이자

	if (menu == 1) {
			// -------성적입력부분------------------------------
			System.out.println("┌──────────────────────────┐");
			System.out.println("│          성적입력        │");
			System.out.println("└──────────────────────────┘");
			
			System.out.print("국어1:");
			kor1 = sc.nextInt();

			do {
				System.out.print("국어1:");
				kor1 = sc.nextInt();
				if (kor1 < 0 || kor1 > 100) {
					System.out.println("성적 범위(0~100)을 벗어낫습니다.");
				}
			} while(kor1 < 0 || kor1 > 100);
			
			do {
				System.out.print("국어2:");
				kor2 = sc.nextInt();
				if (kor2 < 0 || kor2 > 100) {
					System.out.println("성적 범위(0~100)을 벗어낫습니다.");
				}
			} while(kor2 < 0 || kor2 > 100);

			do {
				System.out.print("국어3:");
				kor3 = sc.nextInt();
				if (kor3 < 0 || kor3 > 100) {
					System.out.println("성적 범위(0~100)을 벗어낫습니다.");
				}
			} while(kor3 < 0 || kor3 > 100);
			
		} else if (menu == 2) {
			// -------성적출력부분------------------------------

			total = kor1 + kor2 + kor3;
			avg = total / 3.0f;

			System.out.println("┌──────────────────────────┐");
			System.out.println("│          성적출력        │");
			System.out.println("└──────────────────────────┘");

			System.out.printf("\t국어1 : %3d\n", kor1);
			System.out.printf("\t국어2 : %3d\n", kor2);
			System.out.printf("\t국어3 : %3d\n", kor3);
			
			System.out.printf("\t총점 : %3d\n", total);
			System.out.printf("\t평균 : %6.2f\n", avg);
			System.out.println("──────────────────────────");
		} else if (menu == 3) {
			//System.exit(0); 프로그램강제 종료는 좋지 않음!!
			break;
		} else {
		
		}
	
			
	}
	System.out.println("good bye~");

if문만으로 구성을 하면? 잘못된다. 1이라면 아니라면 2번 이런식으로 가야한다.
if만이으면 1번이라면 메뉴가 2번인가 또물어본다. 흐름이 중간에 끊긴다.
그래서 else if문을 사용해서 또 비교하지 않고 바로 선택을 해야한다. 
이게 바로 배타적인 흐름이라 한다.
흐름을 따지면서 만들어야한다. 코드가 늘어갈대마다 어떻게 흘러갈지를 생각하면서 만들어라.
동작만 잘되면 잘되는게 아니라 비효율적일때 그것을 알아야 좋은 프로그래머가 될 수 있다.


32. 제어구조 switch와 break 라벨문
그런데 elseif는 메뉴를 하기엔 적절하지 않음.
대략적으로는 배타적이지만 메뉴의 수가 많아지면? 아니면아니면아니면을 계속해서 흐름이 길어진다.
메뉴가 200개면? 마지막꺼는 앞에것을 거치고 와야해서 매우 비효율적이게 됨
그래서 메뉴는 바로 바로 선택할 수 있게 해줘야함.
이런 분기문을 이용하는 것이 switch이다. 1번이면 1번으로 2번이면 2번으로 3번이면 3번으로 바로바로감
라벨을 가지고 라벨을 해당하는 case로 점프한다. 다음을 실행하지 않겟다면 break;를 넣어주자.
의도적으로 매 블럭마다 break;안쓰는 경우도 잇다.

그런데 swtich에서 break를하면 스위치를 벗어나는거지 while을 끝내는게 아니다.
while문을 끝까지 벗어나고 싶다? 옛날에는 go to문이 잇엇는데 라벨을 사용하면된다.
break 라벨; 하면 라벨이 있는 곳 까지 벗어나게 된다.

sec12 예제실습

33. 제어구조 continue와 break문
프로그래머라면 제어구조를 잘해야한다. 프로그래머는 단순히 일자형태의 흐름을 만드는게 아니라 반복 선택하는 절차를 만드는 사림이기 때문이다.
프로그램은 단순하다 무조건 반복을 한다. 반복되는 과정에서 건너뛰는게 잇다면 그것이 continue이다. 중단하는 것은 break이다.

scanner의 next는34 5 6 234 이런식으로하면 스페이스를 구분자로해서 하나만 읽는다. 입력버퍼가 잇어서 또 받으려면 다음것 5가 들어가게 됨.

while (sc.hasNext()) {
	n = sc.nextInt();
	if (n < 10) {
		continue;
	}
	if (n > 200) {
		break;
	}
	System.out.print(n);
}

10보다 작으면 스킵하고 200이넘으면 끝나게 만들어보앗다.

34. 배열이란?
프로그램의 기본은 계산이다.
저장소를 하나 마련하고 쭉 입력해놓고 그거로 계산하고 출력한다.
이저장소를 구현하는데 문제점이잇다. 만약 점수를 하나만 저장하면 지금까지 배운거로 상관이없다.
만약 국어성적을 100개하면 변수 100번선언해야된다. 만약 초기값으로 1을대입하면? 똑같은 문장이 반복되서 비효율적이다.

공간을 마련할때 다인방을 마련하면?공간을 좀 잘게 잘라서 연산하면 편하다.

이런 여러값을 담을 수있는 큰방이 배열이다.

배열을 어떻게 담나? 값을 여러개 담기때문에 값의 형식이뭐냐에 따라서 달라진다.
큰방을 쓴다고 표현하기위해 []을쓴다. 그리고 자료형을 알려줘야한다.
int[] -> 크기를 정해야해서 숫자를 넣고 new를 써준다 new int[3]; 그리고 이 공간이 객체이고 이름이 필요하다.
-> int[] kors = new int[3];
kors[1] 어느위치에 값을 넣을 것인지 정해줘야한다. 1이면 정수만큼 4바이트이동한다. 그공간을 잘라서 할당한다.
kors[1] = 1이렇게 값을 넣어줘야한다.
이런식으로 연산을 해서 큰공간을 활요하게 되면 여러값을 할당할 수 있게 된다.ㄴ
안쪽의 값이 달라지는 것임. 

문제 영어 성적을 위한 배열을 선언하시오s
int[] engs = new int[3];

확인문제
kors == engs ->배열이 같은 객체냐? 주소가 같냐를 물어보는 연산이다.
kors[0] == engs[0] -> 값이 같느냐를 물어보는 연산이다.

35. 배열을 이용해서 국어성적 관리하기
예제에 배열을 활용해보자.

36. 다차원 배열
다차원배열이라느 2차원배열이다.
한학년의 국어 성적이 필요한 것임. 3학년동안 3번씩 9번
int[] kors1 ㅁㅁㅁ
int[] kors2 ㅁㅁㅁ
int[] kors3 ㅁㅁㅁ
이름을 하나로 가져가고 논리적으로 나누는게 나을 수잇다.
int[] kors ㅁㅁㅁㅁㅁㅁㅁㅁㅁ
이걸 나눠서 마치 3칸씩 1학년 2학년 3학년으로 나누는게 좋다.
kors[3*0] kors[3*1] kors[3*2] 이런식으로 나누어가지면 된다.
사진참조
그런데 이렇게 개념적으로 사용하면 오히려 불편하다.
그래서 kors[0][0] kors[1][1]이런식으로 다차원배열을 지원하게 되엇다.
사진참조2

1차원배열을 나누면 int[3*3] 으로 해두면된다. 그런데 매우 불편하다.

37. - 다차원 배열 표현식
예제실습  15 mraray

38.  상수형 변수
변수를 사용할 수있는데 상수형 변수는 뭘까?
게임을 하는데 방향을 저장할 필요가 잇다.
int dirction; 각방향을 숫자에 넣는 경우가 잇다.
direction = 4; 하면? 나중에 다시 보면 4가 어느방향인지 잊게 된다.
그래서 direction = SE;하면 편하다.
int N = 1;이런식으로 담는다. 문제가 하나잇다. 이 변수가 다른값으로 바뀌면 문제가 된다.
그래서 불안하니 상수로 만들면된다
final int N = 1; 항상 같은 값을 가지는 변수 라서 상수 라고 한다. 이 상수형변수는 매우 잘 사용된다.








